---
title: 常见分布式事务解决方案
date: 2018-09-30 23:14:26
tags: 分布式事务
categories: 技术
---

### 消息中间件的使用场景
消息中间件在分布式系统中的主要作用是: **异步通讯、解耦、并发缓冲**

### 消息发送和投递的不可靠性
![-w754](http://p7b5cwgjy.bkt.clouddn.com/15382779878593.jpg)
在分布式部署环境下，需要通过网络进行通讯，就引入了数据传输的不确定性，也就是CAP理论中的P（分区容错性的问题）

### 消息发送一致性
消息发送一致性： 是指产生消息的业务动作与消息发送的一致（也就是说，如果业务操作成功，那么由这个业务操作锁产生的消息一定要成功投递出去，否则就丢消息）

## 消息发送一致性如何保障？
方式1：
```java
public void completeOrder(){
    //业务处理
    orderBiz.process();
    //发送消息
    sendAccountMsg();
}
```
问题： 1. 业务操作成功，消息发送前应用突然故障，消息没发出去，导致消息丢失（订单系统与会计系统数据不一致）
2.业务操作成功，应用正常，但消息系统故障或者网络故障，导致消息发不出去（订单系统与会计系统数据不一致）

方式2：
```java
public void completeOrder(){
    //发送消息
    sendAccountMsg();
    //业务处理
    orderBiz.process();
}
```
问题：这种情况更不可控，消息发送出去了，但业务可能会失败。

### JMS标准中XA协议方式是否可以保证发送一致性？
JMS标准API中有很多XA开头的接口，就是前面提到的支持XA协议（基于两阶段提交协议）的全局事务型接口。可以提供分布式事务支持。
但是引入XA放的分布式事务，又带来了很多局限：
- 要求业务操作资源必须支持XA协议（并不是所有的资源都支持XA）
- 两阶段提交协议的成本
- 持久化成本等DTP模型的局限性（全局锁定，成本高，性能低）
  ==引入XA，违背了柔性事务的初衷!==


## 消息发送一致性：变通的做法
![-w759](http://p7b5cwgjy.bkt.clouddn.com/15382853471013.jpg)

消息发送一致性方案的正向流程是可行的，但异常流程是怎么处理呢？
消息发送到消息中间件中能得到保障了，但是的准确消费（投递）又如何保障呢？
有没有支持这种发送一致性流程的线程消息中间件？

![-w754](http://p7b5cwgjy.bkt.clouddn.com/15382890478843.jpg)
**任何一个环节都有可能出问题!**
**1.从主动方应用的角度分析：**

| 异常情况                                           | 可能状态                                                     | 一致性 |
| -------------------------------------------------- | ------------------------------------------------------------ | ------ |
| 预发消息失败                                       | 消息未进存储，业务员操作未执行（可能原因：主动方应用、网络、消息中间件、消息存储） | 一致   |
| 预发消息发送，而主动方没有收到返回消息存储结果     | 1.消息未进行存储，业务操作未执行                             | 一致   |
|                                                    | 2.消息已存储（待确认），业务操作未执行                       | 不一致 |
| 收到消息存储成功的返回结果，但未执行业务操作就失败 | 消息已进存储（待确认）,业务操作未执行                        | 不一致 |

**2.从消息中间件的角度来分析**

| 异常情况                                                     | 可能状态                                                     | 一致性 |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------ |
| 消息中间件没有收到主动方应用的业务操作处理结果               | 1.消息已进存储（待确认），业务操作未执行（或业务操作出错回滚了） | 不一致 |
|                                                              | 2.消息已进存储（待确认），业务操作成功                       | 不一致 |
| 消息中间件收到业务操作结果(成功/失败)，但处理消息存储中的消息状态失败 | 1.消息已进存储（待确认），业务操作未执行（或者业务操作出错回滚） | 不一致 |
|                                                              | 2.消息已进存储（待确认），业务操作成功                       | 不一致 |

**异常情况总结及处理：**

| 异常情况                             | 一致性 | 异常处理方法                                             |
| ------------------------------------ | ------ | -------------------------------------------------------- |
| 消息未存储，业务操作未执行           | 一致   |                                                          |
| 消息已存储（待确认），业务操作未执行 | 不一致 | 确认消息操作结果，处理消息（删除）                       |
| 消息已存储（待确认），业务操作成功   | 不一致 | 确认消息操作结果，处理消息（更新消息状态，执行消息投递） |

![-w755](http://p7b5cwgjy.bkt.clouddn.com/15382933644912.jpg)
异常处理流程也有可能发生异常，只需重复执行上述流程即可。

# 消息队列
## MQ队列模型的特点
- 消息生产者发送消息至Queue中，消费者监听Queue并接受消息
- 消息被消费后，就回从Queue中删除，所以消费者不会消费到已经被消费的消息
- Queue支持存在多个消费者，但是对于某一个消费者而言，只会有一个消费者成功消费

![-w650](http://p7b5cwgjy.bkt.clouddn.com/15407936627321.jpg)
MQ队列生产消费常规流程
1.Producer生产消息并发送给MQ（同步、异步）
2.MQ接收消息并将消息数据持久化到消息存储(持久化可选)
3.MQ向Producer返回消息的接受结果(返回值、异常)
4.Consumer监听并消费MQ中的消息
5.Consumer获取到消息后执行业务处理
6.Consumer对已成功消费的消息向MQ进行ACK确认（确认后从MQ中删除）

### 与消息发送一致性对比
1.常规MQ队列消息的处理流程无法实现消息发送的一致性
2.投递消息的流程其实是消息的消费过程，可细化

![-w758](http://p7b5cwgjy.bkt.clouddn.com/15407945163524.jpg)
可靠消息的生产与消费的正向流程
6.被动方应用监听接收“待发送”状态的消息，执行业务处理；
7.业务处理完毕，想消息中间件发送ACK，确认消息已经收到（消息中间件从队列中删除该消息）

## 消息重发的原因
![-w531](http://p7b5cwgjy.bkt.clouddn.com/15412127286627.jpg)
1. 被动应用接收消息，业务处理完成后应用出现问题，消息中间件不知道消息处理结果，会重新投递消息。
2. 被动方接收到消息，业务处理完成后网络故障，消息中间件不能接收到消息处理结果，会重新投递消息。
3. 被动方接收到消息，业务处理耗时过长，消息中间因消息超时未确认，会重新投递消息。
4. 被动方接收到消息，业务处理完成，消息中间件问题导致收不到消息处理结果，消息会重新投递
5. 被动方接收到消息，业务处理完成，消息中间件收到消息，但由于消息存储故障导致消息没能成功确认，消息会再次投递

总结，消息消费过程中产生消息重复发送的主要原因是消息没能及时的ACK确认。
==约束：被动方应用对于消息的业务处理必须实现幂等。==

