---
title: RabbitMQ
date: 2018-09-24 15:59:08
tags: RabbitMQ
categories: 技术
---



## 特点

消息中间件：是消息传输过程中保存消息的容器，充当中间人的作用

队里的主要目的提供路由保证消息的传递

如果发送消息时，接受者不可用，队列会保留消息，直至成功传递，当然保存消息也是尤期限的。

- 采用异步处理方式
  消息发送者可以发送一个消息无需等待响应。消息发送者将消息发送到一条虚拟的通道（队列或者主题）上，消息接受者则是监听或订阅该通道。一条消息可以转发给一个或多个接收者，这些接收者无需对消息发送者同步回应。
- 应用之间调用是松耦合的
  发送者和接受者不必了解对方、只需确认消息
  发送者、接收者不必同时在线。比如在线交易系统为了保证数据**最终一致性**，在支付系统处理完毕后把支付结果放到消息中间件里通知订单系统修改订单状态。两个系统通过消息解耦

## 消息传递服务模型
- 点对点模型（PTP）
  消息生产者将消息发送到指定名字标识的特定消费者（队列），队列消息可以放在内存中，也可以持久化。
  特点：1.每个消息只有一个消费者
  2.发送者好接收者没有时间依赖
  3.接收者确认消息接受和处理成功（ACK）
- 发布-订阅模型（Pub/Sub）
  发布者和订阅者彼此不知道对方，多个消费者可以获得消息，在发布者和订阅者之间存在时间依赖性（时刻保持订阅关系）。发布者简历订阅（subscription）,以便消费者订阅。订阅者必须保持持续的活动状态已接受消息，除非订阅者建立了持久的订阅。在这种情况下，在订阅者为连接时发布的消息将在订阅者重新连接时重新发布。
  特点： 1.每个消息可以有多个订阅者
  2.客户端只有订阅后才能接收到消息
  3.持久订阅和非之久订阅
  持久订阅，订阅关系建立后，消息不呼呼消失，不管订阅者是都在线
  非持续订阅，为了接受消息，订阅者必须一直在线

## 使用案例
- 数据复制
- 延迟消息发送和暂存
  1.把中间件当做可靠的消息暂存地（指定时间内不删除的）
  2.定时进行消息投递，比如模拟用户秒杀访问，进行西戎性能压测
- 消息广播
  1.缓存数据同步更新
  2.往缓存应用推送数据，比如更新本地缓存 一般使用租约解决数据不一致问题

## 消息中间件分类

1.push 推消息模型：消息生产者将消息发送给消息传递服务，消息传递服务又将消息推给消息消费者。
2.pull 拉消息模型，消费者请求消息服务接收消息，消息生产者从消息中间件拉取该消息。
### 两种类型区别

| 模型       | push                                                         | pull                                                         |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 服务端     | 消息存储<br />处理请求<br />保存推送轨迹<br />保存订阅关系<br />消费者负载均衡<br />集中式 | 消息存储<br />处理请求<br />分布式                           |
| 客户端     | 处理响应请求                                                 | 处理响应和请求<br />保存pull状态，如拉取位置偏移量offset<br />异常情况下的消息暂存和rerecover |
| 实时性     | 较好。收到数据后立即发送客户端                               | 取决于pull的间隔时间                                         |
| 消费者故障 | 消费者故障情况下，服务端堆积消息，重复推送耗费资源<br />保存推送轨迹压力很大 | 消费者故障，对服务端无影响                                   |
| 其他       | 更多控制，能够实现多样化的推送机制<br />当消费者数量增多时，推送压力较大，性能天花板<br />消费者处理能力差异，导致堆积消息 | 需要在客户端实现消息过滤，浪费资源<br />需要在不同客户端之间协调，做负载均衡 |

 ## RabbitMQ

RabbitMQ是一个在AMQP协议标准基础上完整的，可服务企业消息系统。AMQP（高级消息队列协议）是一个异步消息传递所使用的应用层协议规范，作为线路层协议，而不是API（例如JMS）

### 运行原理

RabbitMQ两大核心组件Exchange和Queue，运行原理图![image-20180924223023620](/var/folders/bp/cscsbss94b11pxqq51g50d680000gn/T/abnerworks.Typora/image-20180924223023620.png)

### 重要术语

1.**server（broker）**：接受客户端连接，失效AMQP消息队列和路由功能的进程

2.**Virtual Host**: 其实这是一个虚拟概念，类似权限控制组，一个Virtual Host里面可以有若干个Exchange和Queue，但是权限控制的最小粒度是Virtual Host

3.**Exchange**: 接受生产者发送的消息，并根据Binding规则将消息**路由**给服务器队列。ExchangeType决定了Exchange路由的行为。在RabbitMQ中，ExchangeType有**direct、Fanout、Topic** 三种，不同类型的Exchange路由行为不同。

- **Direct Exchange**：直接交互式路由键。需要将一个队列绑定到交换机上，要求消息与一个特定的路由键完全匹配

- **Fanout Exchange**: 广播式路由键。只需简单的将队列绑定到交换机上。一个发送到交换机上的消息就回被转发到该交换机绑定的所有队列上。Fanout交换机转发消息是最快的。

- **Topic Exchange**: 主题式交换器。通过消息的路由关键字和绑定关键字的模式匹配，将消息路由到绑定的队列中。这种路由类型可以被用来支持经典的发布/订阅消息传输模型--使用主题名字空间作为消息寻址模式，将消息传递给哪些或全部主题模式的多个消费者。主题交换器类型的工作方式如下：绑定关键字用零个或多个标记组成，每个标记之间用“.”分隔，并支持通配符：“*”匹配一个词组，“#”零个或多个词组。因此绑定关键字` *.statck.#`匹配路由关键字“usd.statck”和“eur.stack.db”，但不匹配“stack.nasdaq”

4.**Message Queue**：消息队列，用于存储还未被消费者消费的消息。

5.**Message**：有Header、Body组成，Header是由生产者添加的各种属性集合，包括消息Message是否被持久化，由那个Message Queue接收，优先级是多少等；而body才是真正需要的业务数据。

6.**Binding Key**：所谓绑定指的是，将一个特定Exchange和一个特定Queue绑定起来，而他们绑定关系使用的就是Binding Key