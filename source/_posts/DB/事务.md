---
title: 事务
date: 2017-08-20 00:52:39
tags: [DB,事务]
categories: 技术
---

一个运行了良好的事务处理系统，必须具备这些特征

ACID：原子性（atomatic）、一致性（consistency）、隔离性（isolation）和持久性（durability）

原子性：一个事务必须视为一个不可分割的最小工作单元你，整个事务的所有操作要么全提交成功，要么全失败回滚。对于一个事务来说，不可能只执行其中一部分操作，这就是事务原子性。

一致性：数据库总是从一个一致性状态转移到另一个一致性状态。比如即使三四句之间系统崩溃，账户系统也不会凭空损失200美元，因为事务没有提交，所以事务中所做的修改也不会保存到数据库中。

隔离性：通常，一个事务所做的一系列修改在最终提交以前，对其他事务是不可见的。当然这和后面要说的**隔离级别**有关系。

持久性：一旦事务提交，则其所作的修改就回永久保存到数据库中。但实际上持久性也分很多不同级别。有些持久策略能够提供非常强的安全保障，而有些未必。
<!--more-->

### 隔离级别

在SQL标准中定义了四种隔离级别，每一种级别规定了一个事务中所做的修改，哪些在事务内核事务间是可见的，哪些是不可见了。**较低级别的隔离通常是可以执行更高的并发**，系统的开销也更低。

每种存储引擎实现的隔离级别不尽相同。

**READ UNCOMITTED(未提交读)**

在read uncomited级别，事务中的修改，即使没有提交，对其他事务是可见的。事务可以读取未提交的数据，这也被称为**脏读**（Dirty Read）。这个级别会导致很多问题，从性能上来讲，read uncommited不会不其他级别的好太多，却缺乏其他级别的好处，除非真的有必要的理由，在实际中很少使用。

**READ COMMITED(提交读)**

大多数数据库的默认隔离级别都是read commited（但mysql不是）。read commited满足前面调到的隔离性的简单定义，一个事务从开始知道提交之前，所做的任何修改对其他事务都是不可见的。这个级别也叫做**不可重复读**（nonrepeatable read），因为两次执行同样的查询，可能得到不同的结果。

**REPEATABLE READ(可重复读)**

Repeadtable read解决了脏读的问题，该级别保证了在同一个事务中多次读取同样记录的结果是一致的。但是理论上，可重复读隔离级别还是无法解决另一个**幻读**（Phantom Read）的问题。所谓幻读，指的是当某个事务读取某个范围内的记录时，另外一个事务有在该范围内插入新的记录，当之前的事务再次读取该范围的记录时产生了**幻行**（Phantom Row）。InnoDB和XtraDB存储引擎通过多版本并发控制(MVCC)解决了解决幻读。

可重复读是MYSQL的默认事务隔离级别

**SERIALIZABLE(可串行化)**

最高隔离级别。它通过强制事务穿行执行，避免前面说的幻读问题，简单说他会在读取的每一行数据都加锁，所以导致大量的超时和锁争用问题。很少使用，只有非常需要确保数据一致性而且可以接受没有并发的情况下，才考虑采用该级别。

| 隔离级别            | 脏读可能性 | 不可重复读可能性 | 幻读可能性 | 加锁读  |
| --------------- | ----- | -------- | ----- | ---- |
| READ UNCOMMITED | YES   | YES      | YES   | NO   |
| READ COMMITED   | NO    | YES      | YES   | NO   |
| REPEATABLE READ | NO    | NO       | YES   | NO   |
| SERIALIZABLE    | NO    | NO       | NO    | YES  |



### 死锁

死锁是指两个或者多个事务在同一个资源上相互占用，并请求资源锁定对方占用的资源，从而导致恶性循环的现象。当多个事务试图以不同的顺序锁定资源时，就可能产生死锁。多个事务同时锁定同一个资源时，也会产生死锁。
